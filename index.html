<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Meine D&D Welt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="leaflet/dist/leaflet.css">
  <script src="leaflet/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      font-family: sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #alert-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9000;
    }

    .alert-box {
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 14px 18px;
      margin-top: 8px;
      border-radius: 8px;
      max-width: 90vw;
      white-space: pre-wrap;
      animation: fade 5s forwards;
    }

    @keyframes fade {
      0% { opacity: 0 }
      10% { opacity: 1 }
      90% { opacity: 1 }
      100% { opacity: 0 }
    }

    #event-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #event-box {
      background: #111;
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 90vw;
    }

    #event-choices button {
      display: block;
      width: 100%;
      margin-top: 10px;
      padding: 12px;
      font-size: 16px;
    }
  </style>
</head>

<body>
  <div id="inventory-overlay"
  style="
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    z-index:10000;
    color:white;
    padding:20px;
    overflow:auto;">
  <h2>Inventar</h2>
  <ul id="inventory-list"></ul>
  <button onclick="closeInventory()">Schlie√üen</button>
</div>
<button id="inventory-btn"
  style="
    position: fixed;
    top: 15px;
    right: 15px;
    z-index: 10001;
    padding: 10px 14px;
    font-size: 16px;
    background: #111;
    color: #fff;
    border-radius: 8px;
    border: none;">
  üéí Inventar
</button>
<button id="quest-btn"
  style="
    position: fixed;
    top: 60px;
    right: 15px;
    z-index: 10001;
    padding: 10px 14px;
    font-size: 16px;
    background: #111;
    color: #fff;
    border-radius: 8px;
    border: none;">
  üìú Quests
</button>
<div id="quest-overlay"
  style="
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    z-index:10000;
    color:white;
    padding:20px;
    overflow:auto;">
  <h2>Quests</h2>
  <ul id="quest-list"></ul>
  <button onclick="closeQuests()">Schlie√üen</button>
</div>

<div id="event-overlay">
  <div id="event-box">
    <h2 id="event-title"></h2>
    <p id="event-text"></p>
    <div id="event-choices"></div>
  </div>
</div>
<div id="storage-overlay"
  style="
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    z-index:10000;
    color:white;
    padding:20px;
    overflow:auto;">
  <h2>üì¶ Lager</h2>

  <h3>üéí Dein Inventar</h3>
  <ul id="storage-player-list"></ul>

  <h3>üì¶ Stauraum</h3>
  <ul id="storage-poi-list"></ul>

  <button onclick="closeStorage()">Schlie√üen</button>
</div>

<div id="map"></div>
<div id="alert-container"></div>

<script>
  let forcedEventActive = false;
  let hasCenteredMap = false;
  let discoveryLock = new Set();
  let activeStoragePoi = null;
/* ================= SUPABASE ================= */
const SUPABASE_URL = "https://pzghhhgoqidhddifolva.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB6Z2hoaGdvcWlkaGRkaWZvbHZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYwNzkyMTcsImV4cCI6MjA4MTY1NTIxN30.lRsdxk46AG_eOam_YCFQONZ0kbzPK0m3NH6RgC9Iq_s";

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
let currentUser = null;

async function initAuth() {
  const { data } = await sb.auth.getSession();
  if (data.session) {
    currentUser = data.session.user;
    return;
  }

  const email = prompt("E-Mail:");
  const password = prompt("Passwort:");

  const { data: loginData, error } =
    await sb.auth.signInWithPassword({ email, password });

  if (error) throw error;
  currentUser = loginData.user;
}

/* ================= MAP ================= */
// ================= POI ICONS =================

const defaultPoiIcon = L.icon({
  iconUrl: "assets/icons/default.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const baseIcon = L.icon({
  iconUrl: "assets/icons/base.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const battleIcon = L.icon({
  iconUrl: "assets/icons/battle.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const pawIcon = L.icon({
  iconUrl: "assets/icons/paw.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});
const aidIcon = L.icon({
  iconUrl: "assets/icons/aid.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});
const shopIcon = L.icon({
  iconUrl: "assets/icons/shop.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});
const academyIcon = L.icon({
  iconUrl: "assets/icons/academy.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

function getPoiIcon(poi) {
  switch (poi.poi_type) {
    case "base":
      return baseIcon;
    case "battle":
      return battleIcon;
    case "paw":
      return pawIcon;
    case "aid":
      return aidIcon;
    case "shop":
      return shopIcon;
    case "academy":
      return academyIcon;
    default:
      return defaultPoiIcon;
  }
}
const map = L.map("map").setView([51.5, 10], 6);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "&copy; OpenStreetMap"
}).addTo(map);

/* ================= UI ================= */
function showAlert(text) {
  const box = document.createElement("div");
  box.className = "alert-box";
  box.textContent = text;
  document.getElementById("alert-container").appendChild(box);
  setTimeout(() => box.remove(), 5000);
}
async function openStorage(poi) {
  activeStoragePoi = poi;
  document.getElementById("storage-overlay").style.display = "block";
  await refreshStorageUI();
}
function closeStorage() {
  activeStoragePoi = null;
  document.getElementById("storage-overlay").style.display = "none";
}
/* ================= GEO ================= */
let userLat, userLng, userMarker;

function startGPS() {
  if (!("geolocation" in navigator)) {
    alert("Geolocation wird vom Browser nicht unterst√ºtzt");
    return;
  }

  console.log("Starte GPS‚Ä¶");

  navigator.geolocation.getCurrentPosition(
    pos => {
      console.log("Initiale Position:", pos.coords.latitude, pos.coords.longitude);
      handlePosition(pos);
    },
    err => {
      console.error("GPS Initial Fehler:", err);
      alert("Standort konnte nicht ermittelt werden: " + err.message);
    },
    { enableHighAccuracy: true }
  );

  navigator.geolocation.watchPosition(
    pos => handlePosition(pos),
    err => console.error("GPS Watch Fehler:", err),
    { enableHighAccuracy: true }
  );
}

async function handlePosition(pos) {
  userLat = pos.coords.latitude;
  userLng = pos.coords.longitude;

  console.log("GPS Update:", userLat, userLng);

 if (!hasCenteredMap) {
  map.setView([userLat, userLng], 16);
  hasCenteredMap = true;
}

  if (!userMarker) {
    userMarker = L.marker([userLat, userLng])
      .addTo(map)
      .bindPopup("Du bist hier")
      .openPopup();
  } else {
    userMarker.setLatLng([userLat, userLng]);
  }

  await loadPOIs();
}

/* ================= UTILS ================= */
function distance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;

  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
async function shouldShowPoi(poi) {
  const discovered = await hasDiscovered(poi.id);
  if (discovered) return true;

  const d = distance(userLat, userLng, poi.lat, poi.lng);
  if (d <= poi.radius) return true;

  return false;
}

/* ================= DISCOVERY ================= */
async function hasDiscovered(poiId) {
  const { data } = await sb
    .from("poi_discoveries")
    .select("id")
    .eq("poi_id", poiId)
    .eq("player_id", currentUser.id)
    .limit(1);

  return data.length > 0;
}
function isPoiActiveNow(poi) {
  const now = new Date();

  const startsAt = poi.starts_at ? new Date(poi.starts_at) : null;
  const endsAt   = poi.ends_at   ? new Date(poi.ends_at)   : null;

  if (startsAt && now < startsAt) return false;
  if (endsAt   && now > endsAt)   return false;

  return true;
}

async function saveDiscovery(poiId) {
  const res = await sb
    .from("poi_discoveries")
    .insert({
      poi_id: poiId,
      player_id: currentUser.id
    });

  if (res.error) {
    console.error("Discovery insert failed:", res.error);
  }

  return res;
}



/* ================= INSPECT EVENTS + CHOICES ================= */
async function getInspectEvent(poiId) {
  const { data, error } = await sb
    .from("poi_events")
    .select("*")
    .eq("poi_id", poiId)
    .eq("event_type", "inspect")
    .limit(1);

  if (error) return null;
  return data?.[0] ?? null;
}

async function getChoices(eventId) {
  const { data } = await sb
    .from("poi_choices")
    .select("*")
    .eq("event_id", eventId);

  return data || [];
}

async function getPlayerChoice(eventId) {
  const { data, error } = await sb
    .from("player_choices")
    .select("choice_id, poi_choices(result_text)")
    .eq("event_id", eventId)
    .eq("player_id", currentUser.id)
    .limit(1);

  if (error || !data || data.length === 0) return null;
  return data[0];
}

async function savePlayerChoice(eventId, choiceId) {
  await sb.from("player_choices").insert({
    event_id: eventId,
    choice_id: choiceId,
    player_id: currentUser.id
  });
}

async function openInspectEvent(event) {
  const overlay = document.getElementById("event-overlay");
  const title = document.getElementById("event-title");
  const text = document.getElementById("event-text");
  const box = document.getElementById("event-choices");

  overlay.style.display = "flex";
  title.textContent = event.title;
  text.textContent = event.description;
  box.innerHTML = "";

  // 1Ô∏è‚É£ Bereits gew√§hlte Entscheidung anzeigen
  const existing = await getPlayerChoice(event.id);
  if (existing) {
    text.textContent = existing.poi_choices.result_text;

    const btn = document.createElement("button");
    btn.textContent = "Schlie√üen";
    btn.onclick = () => overlay.style.display = "none";
    box.appendChild(btn);
    return;
  }

  // 2Ô∏è‚É£ Choices laden
  const choices = await getChoices(event.id);
  console.log("Choices:", choices);

  if (!choices.length) {
    const btn = document.createElement("button");
    btn.textContent = "Schlie√üen";
    btn.onclick = () => overlay.style.display = "none";
    box.appendChild(btn);
    return;
  }

  // 3Ô∏è‚É£ Choice-Buttons bauen
  for (const choice of choices) {
    const choiceBtn = document.createElement("button");
    choiceBtn.textContent = choice.label;

    choiceBtn.onclick = async () => {
      await savePlayerChoice(event.id, choice.id);

      // ‚≠ê Items vergeben
      const items = await getItemsForChoice(choice.id);
      for (const itemKey of items) {
        await giveItem(itemKey);
      }
// ‚≠ê Quests vergeben
const quests = await getQuestsForChoice(choice.id);
for (const questKey of quests) {
  await giveQuest(questKey);
}
      text.textContent = choice.result_text;
      box.innerHTML = "";

      const closeBtn = document.createElement("button");
      closeBtn.textContent = "Weiter";
      closeBtn.onclick = () => overlay.style.display = "none";
      box.appendChild(closeBtn);
    };

    // ‚≠ê DAS WAR DER FEHLER
    box.appendChild(choiceBtn);
  }
}


async function getForcedEvents(poiId) {
  const { data } = await sb
    .from("poi_events")
    .select("*")
    .eq("poi_id", poiId)
    .eq("event_type", "forced")
    .eq("auto_trigger", true);

  return data || [];
}
async function triggerForcedEvent(event, poiId) {
  if (forcedEventActive) return;

  const alreadyTriggered = await hasTriggeredForcedEvent(event.id);
  if (alreadyTriggered) return;

  forcedEventActive = true;

  // ‚úÖ remember forced event
  await sb.from("player_forced_events").insert({
    player_id: currentUser.id,
    event_id: event.id,
    poi_id: poiId
  });

  // ‚úÖ ALSO mark POI as discovered (IMPORTANT)
if (!discoveryLock.has(poiId)) {
  discoveryLock.add(poiId);
  await saveDiscovery(poiId);
}

  // ‚úÖ now show the event
  await tryOpenEvent(event);

  // Overlay observer
  const overlay = document.getElementById("event-overlay");
  const observer = new MutationObserver(() => {
    if (overlay.style.display === "none") {
      forcedEventActive = false;
      observer.disconnect();
    }
  });

  observer.observe(overlay, { attributes: true });
}

async function hasTriggeredForcedEvent(eventId) {
  const { data, error } = await sb
    .from("player_forced_events")
    .select("id")
    .eq("player_id", currentUser.id)
    .eq("event_id", eventId)
    .limit(1);

  if (error) {
    console.error("Forced event check failed:", error);
    return false;
  }

  return data.length > 0;
}

/*==================Inventory===========*/
async function refreshStorageUI() {
  if (!activeStoragePoi) return;

  const playerList = document.getElementById("storage-player-list");
  const poiList = document.getElementById("storage-poi-list");

  playerList.innerHTML = "";
  poiList.innerHTML = "";

  // üéí Spielerinventar
  const { data: playerItems } = await sb
    .from("player_items")
    .select("id, items(name)")
    .eq("player_id", currentUser.id);

  if (!playerItems.length) {
    playerList.innerHTML = "<li>Leer</li>";
  } else {
    for (const row of playerItems) {
      const li = document.createElement("li");
      li.textContent = row.items.name;

      const btn = document.createElement("button");
      btn.textContent = "‚Üí Lagern";
      btn.onclick = () => storeItem(row.id);

      li.appendChild(btn);
      playerList.appendChild(li);
    }
  }

  // üì¶ POI Lager
  const { data: storedItems } = await sb
    .from("poi_storage")
    .select("id, items(name)")
    .eq("poi_id", activeStoragePoi.id);

  if (!storedItems.length) {
    poiList.innerHTML = "<li>Leer</li>";
  } else {
    for (const row of storedItems) {
      const li = document.createElement("li");
      li.textContent = row.items.name;

      const btn = document.createElement("button");
      btn.textContent = "‚Üê Nehmen";
      btn.onclick = () => takeItem(row.id);

      li.appendChild(btn);
      poiList.appendChild(li);
    }
  }
}
async function storeItem(playerItemId) {
  // 1. Item laden
  const { data: itemRow, error: fetchErr } = await sb
    .from("player_items")
    .select("id, item_id")
    .eq("id", playerItemId)
    .eq("player_id", currentUser.id)
    .maybeSingle();

  if (fetchErr || !itemRow) {
    console.error("Item nicht gefunden oder keine Rechte", fetchErr);
    return;
  }

  // 2. L√∂schen (MIT R√ºckgabe!)
  const { data: deleted, error: delErr } = await sb
    .from("player_items")
    .delete()
    .eq("id", itemRow.id)
    .select();

  if (delErr || !deleted.length) {
    console.error("L√∂schen fehlgeschlagen", delErr);
    showAlert("Konnte Item nicht einlagern.");
    return;
  }

  // 3. Ins Lager legen
  const { error: insertErr } = await sb
    .from("poi_storage")
    .insert({
      poi_id: activeStoragePoi.id,
      item_id: itemRow.item_id
    });

  if (insertErr) {
    console.error("Einlagern fehlgeschlagen", insertErr);
    showAlert("Item ging verloren ‚Äì bitte melden!");
    return;
  }

  await refreshStorageUI();
}

async function takeItem(storageItemId) {
  // 1. Item laden
  const { data: itemRow } = await sb
    .from("poi_storage")
    .select("item_id")
    .eq("id", storageItemId)
    .maybeSingle();

  if (!itemRow) return;

  // 2. Aus Lager l√∂schen
  await sb.from("poi_storage").delete().eq("id", storageItemId);

  // 3. Spieler bekommt Item
  await sb.from("player_items").insert({
    player_id: currentUser.id,
    item_id: itemRow.item_id
  });

  await refreshStorageUI();
}


/* ================= POIs ================= */
const poiMarkers = new Map();

async function loadPOIs() {
  const { data: pois, error } = await sb
    .from("pois")
    .select("*")
    .eq("active", true);

  if (error || !pois) {
    console.error("Fehler beim Laden der POIs", error);
    return;
  }

for (const poi of pois) {

  // ‚è∞ POI zeitlich pr√ºfen (start / end)
  if (!isPoiActiveNow(poi)) {
    const existingMarker = poiMarkers.get(poi.id);
    if (existingMarker) {
      map.removeLayer(existingMarker);
      poiMarkers.delete(poi.id);
    }
    continue; // ‚¨ÖÔ∏è WICHTIG: nicht return!
  }


    /* ================= FORCED EVENTS ================= */
    const forced = await getForcedEvents(poi.id);
    if (forced.length) {
      const alreadyTriggered = await hasTriggeredForcedEvent(forced[0].id);
      if (!alreadyTriggered) {
        const dForced = distance(userLat, userLng, poi.lat, poi.lng);
if (dForced <= forced[0].trigger_radius) {
  await triggerForcedEvent(forced[0], poi.id);
  // KEIN continue!
}

      }
    }

    /* ================= DISTANCE & DISCOVERY ================= */
    const d = distance(userLat, userLng, poi.lat, poi.lng);
    const discovered = await hasDiscovered(poi.id);

    // üîì PASSIVE DISCOVERY (einmalig, abgesichert)
if (d <= poi.radius && !discovered && !discoveryLock.has(poi.id)) {
  discoveryLock.add(poi.id);

  const res = await saveDiscovery(poi.id);

  if (res.error) {
    console.error("Discovery failed:", res.error);
  } else {
    showAlert("Entdeckt: " + poi.name);
  }
}


    const shouldBeVisible = discovered || d <= poi.radius;
    const existingMarker = poiMarkers.get(poi.id);

    /* ================= MARKER ERSTELLEN ================= */
    if (poi.is_visible && shouldBeVisible && !existingMarker) {
      const marker = L.marker(
        [poi.lat, poi.lng],
        { icon: getPoiIcon(poi) }
      ).addTo(map);

      L.DomEvent.disableClickPropagation(marker);

const onMarkerActivate = async () => {
  if (distance(userLat, userLng, poi.lat, poi.lng) > 15) return;

  // üì¶ LAGER HAT PRIORIT√ÑT
  if (poi.has_storage) {
    openStorage(poi);
    return;
  }

  // üîç normales Inspect-Event
  const event = await getInspectEvent(poi.id);
  if (!event) return;

  const requirements = await getEventRequirements(event.id);
  if (requirements.length > 0) {
    const ok = await hasAllRequiredItems(requirements);
    if (!ok) {
      showAlert("Dir fehlt etwas, um hier weiterzumachen.");
      return;
    }
  }

  await openInspectEvent(event);
};


marker.on("click", onMarkerActivate);
marker.on("touchstart", onMarkerActivate);


      poiMarkers.set(poi.id, marker);
    }

    /* ================= MARKER ENTFERNEN ================= */
    if ((!shouldBeVisible || !poi.is_visible) && existingMarker) {
      map.removeLayer(existingMarker);
      poiMarkers.delete(poi.id);
    }
  }
}
async function giveQuest(questKey) {
  const { data: quest, error } = await sb
    .from("quests")
    .select("id")
    .eq("key", questKey)
    .maybeSingle();

  if (error || !quest) {
    console.error("Quest not found:", questKey);
    return;
  }

  await sb
    .from("player_quests")
    .insert({
      player_id: currentUser.id,
      quest_id: quest.id
    })
    .onConflict("player_id,quest_id")
    .ignore();
}
async function openQuests() {
  const overlay = document.getElementById("quest-overlay");
  const list = document.getElementById("quest-list");
  list.innerHTML = "";

  const { data } = await sb
    .from("player_quests")
    .select("completed, quests(title, description)")
    .eq("player_id", currentUser.id);

  if (!data.length) {
    list.innerHTML = "<li>Keine Quests</li>";
  } else {
    for (const q of data) {
      const li = document.createElement("li");
      li.textContent =
        (q.completed ? "‚úîÔ∏è " : "‚ùå ") +
        q.quests.title +
        (q.completed ? "" : " (offen)");
      list.appendChild(li);
    }
  }

  overlay.style.display = "block";
}

function closeQuests() {
  document.getElementById("quest-overlay").style.display = "none";
}

document
  .getElementById("quest-btn")
  .addEventListener("click", openQuests);


async function giveItem(itemKey) {
  const { data: item, error } = await sb
    .from("items")
    .select("id")
    .eq("key", itemKey)
    .maybeSingle();

  if (error) {
    console.error("Item Query Fehler:", error);
    return;
  }

  if (!item) {
    console.warn("Item nicht gefunden:", itemKey);
    return;
  }

  await sb.from("player_items").insert({
    player_id: currentUser.id,
    item_id: item.id
  });
}

async function hasItem(itemKey) {
  const { data } = await sb
    .from("player_items")
    .select("id, items!inner(key)")
    .eq("items.key", itemKey)
    .eq("player_id", currentUser.id)
    .limit(1);

  return data.length > 0;
}
async function getEventRequirements(eventId) {
  const { data } = await sb
    .from("event_requirements")
    .select("item_key")
    .eq("event_id", eventId);

  return data.map(r => r.item_key);
}
async function hasAllRequiredItems(itemKeys) {
  for (const key of itemKeys) {
    if (!(await hasItem(key))) {
      return false;
    }
  }
  return true;
}
async function tryOpenEvent(event) {
  const requirements = await getEventRequirements(event.id);
  if (requirements.length > 0) {
    const ok = await hasAllRequiredItems(requirements);
    if (!ok) {
      showAlert("Dir fehlt etwas, um hier weiterzumachen.");
      return;
    }
  }

  await openInspectEvent(event);
}

async function completeQuest(questKey) {
  const { data: quest } = await sb
    .from("quests")
    .select("id")
    .eq("key", questKey)
    .maybeSingle();

  if (!quest) return;

  await sb
    .from("player_quests")
    .update({
      completed: true,
      completed_at: new Date().toISOString()
    })
    .eq("player_id", currentUser.id)
    .eq("quest_id", quest.id);
}


async function getItemsForChoice(choiceId) {
  const { data, error } = await sb
    .from("choice_items")
    .select("item_key")
    .eq("choice_id", choiceId);

  if (error) {
    console.error("Choice Items Fehler:", error);
    return [];
  }
async function getQuestsForChoice(choiceId) {
  const { data } = await sb
    .from("choice_quests")
    .select("quest_key")
    .eq("choice_id", choiceId);

  return data.map(r => r.quest_key);
}

  return data.map(r => r.item_key);
}
async function openInventory() {
  const overlay = document.getElementById("inventory-overlay");
  const list = document.getElementById("inventory-list");

  list.innerHTML = "";

  const { data, error } = await sb
    .from("player_items")
    .select("items(name, description)")
    .eq("player_id", currentUser.id);

  if (error || !data || data.length === 0) {
    list.innerHTML = "<li>Keine Gegenst√§nde</li>";
  } else {
    for (const row of data) {
      const li = document.createElement("li");
      li.textContent = `${row.items.name} ‚Äì ${row.items.description ?? ""}`;
      list.appendChild(li);
    }
  }

  overlay.style.display = "block";
}

function closeInventory() {
  document.getElementById("inventory-overlay").style.display = "none";
}

/* ================= START ================= */
initAuth().then(startGPS);

document
  .getElementById("inventory-btn")
  .addEventListener("click", openInventory);
</script>

</body>
</html>
