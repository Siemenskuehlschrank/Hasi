<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Meine D&D Welt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="leaflet/dist/leaflet.css">
  <script src="leaflet/dist/leaflet.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      font-family: sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #alert-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9000;
    }

    .alert-box {
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 14px 18px;
      margin-top: 8px;
      border-radius: 8px;
      max-width: 90vw;
      white-space: pre-wrap;
      animation: fade 5s forwards;
    }

    @keyframes fade {
      0% { opacity: 0 }
      10% { opacity: 1 }
      90% { opacity: 1 }
      100% { opacity: 0 }
    }

    #event-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #event-box {
      background: #111;
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 90vw;
    }

    #event-choices button {
      display: block;
      width: 100%;
      margin-top: 10px;
      padding: 12px;
      font-size: 16px;
    }
  </style>
</head>

<body>

<div id="event-overlay">
  <div id="event-box">
    <h2 id="event-title"></h2>
    <p id="event-text"></p>
    <div id="event-choices"></div>
  </div>
</div>

<div id="map"></div>
<div id="alert-container"></div>

<script>
  let forcedEventActive = false;
  let hasCenteredMap = false;
/* ================= SUPABASE ================= */
const SUPABASE_URL = "https://pzghhhgoqidhddifolva.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB6Z2hoaGdvcWlkaGRkaWZvbHZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYwNzkyMTcsImV4cCI6MjA4MTY1NTIxN30.lRsdxk46AG_eOam_YCFQONZ0kbzPK0m3NH6RgC9Iq_s";

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
let currentUser = null;

async function initAuth() {
  const { data } = await sb.auth.getSession();
  if (data.session) {
    currentUser = data.session.user;
    return;
  }

  const email = prompt("E-Mail:");
  const password = prompt("Passwort:");

  const { data: loginData, error } =
    await sb.auth.signInWithPassword({ email, password });

  if (error) throw error;
  currentUser = loginData.user;
}

/* ================= MAP ================= */
// ================= POI ICONS =================

const defaultPoiIcon = L.icon({
  iconUrl: "assets/icons/default.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const baseIcon = L.icon({
  iconUrl: "assets/icons/base.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const battleIcon = L.icon({
  iconUrl: "assets/icons/battle.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

const wildlifeIcon = L.icon({
  iconUrl: "assets/icons/paw.png",
  iconSize: [48, 48],
  iconAnchor: [24, 48]
});

function getPoiIcon(poi) {
  switch (poi.type) {
    case "base":
      return baseIcon;
    case "battle":
      return battleIcon;
    case "ambush":
      return wildlifeIcon;
    default:
      return defaultPoiIcon;
  }
}
const map = L.map("map").setView([51.5, 10], 6);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "&copy; OpenStreetMap"
}).addTo(map);

/* ================= UI ================= */
function showAlert(text) {
  const box = document.createElement("div");
  box.className = "alert-box";
  box.textContent = text;
  document.getElementById("alert-container").appendChild(box);
  setTimeout(() => box.remove(), 5000);
}

/* ================= GEO ================= */
let userLat, userLng, userMarker;

function startGPS() {
  if (!("geolocation" in navigator)) {
    alert("Geolocation wird vom Browser nicht unterstützt");
    return;
  }

  console.log("Starte GPS…");

  navigator.geolocation.getCurrentPosition(
    pos => {
      console.log("Initiale Position:", pos.coords.latitude, pos.coords.longitude);
      handlePosition(pos);
    },
    err => {
      console.error("GPS Initial Fehler:", err);
      alert("Standort konnte nicht ermittelt werden: " + err.message);
    },
    { enableHighAccuracy: true }
  );

  navigator.geolocation.watchPosition(
    pos => handlePosition(pos),
    err => console.error("GPS Watch Fehler:", err),
    { enableHighAccuracy: true }
  );
}

async function handlePosition(pos) {
  userLat = pos.coords.latitude;
  userLng = pos.coords.longitude;

  console.log("GPS Update:", userLat, userLng);

 if (!hasCenteredMap) {
  map.setView([userLat, userLng], 16);
  hasCenteredMap = true;
}

  if (!userMarker) {
    userMarker = L.marker([userLat, userLng])
      .addTo(map)
      .bindPopup("Du bist hier")
      .openPopup();
  } else {
    userMarker.setLatLng([userLat, userLng]);
  }

  await loadPOIs();
}

/* ================= UTILS ================= */
function distance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;

  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* ================= DISCOVERY ================= */
async function hasDiscovered(poiId) {
  const { data } = await sb
    .from("poi_discoveries")
    .select("id")
    .eq("poi_id", poiId)
    .eq("player_id", currentUser.id)
    .limit(1);

  return data.length > 0;
}

async function saveDiscovery(poiId) {
  await sb.from("poi_discoveries").insert({
    poi_id: poiId,
    player_id: currentUser.id
  });
}

/* ================= INSPECT EVENTS + CHOICES ================= */
async function getInspectEvent(poiId) {
  const { data, error } = await sb
    .from("poi_events")
    .select("*")
    .eq("poi_id", poiId)
    .eq("event_type", "inspect")
    .limit(1);

  if (error) return null;
  return data?.[0] ?? null;
}

async function getChoices(eventId) {
  const { data } = await sb
    .from("poi_choices")
    .select("*")
    .eq("event_id", eventId);

  return data || [];
}

async function getPlayerChoice(eventId) {
  const { data, error } = await sb
    .from("player_choices")
    .select("choice_id, poi_choices(result_text)")
    .eq("event_id", eventId)
    .eq("player_id", currentUser.id)
    .limit(1);

  if (error || !data || data.length === 0) return null;
  return data[0];
}

async function savePlayerChoice(eventId, choiceId) {
  await sb.from("player_choices").insert({
    event_id: eventId,
    choice_id: choiceId,
    player_id: currentUser.id
  });
}

async function openInspectEvent(event) {
  const overlay = document.getElementById("event-overlay");
  const title = document.getElementById("event-title");
  const text = document.getElementById("event-text");
  const box = document.getElementById("event-choices");

  overlay.style.display = "flex";
  title.textContent = event.title;
  text.textContent = event.description;
  box.innerHTML = "";

  const existing = await getPlayerChoice(event.id);
  if (existing) {
    text.textContent = existing.poi_choices.result_text;
    const btn = document.createElement("button");
    btn.textContent = "Schließen";
    btn.onclick = () => overlay.style.display = "none";
    box.appendChild(btn);
    return;
  }

  const choices = await getChoices(event.id);
  console.log("Choices:", choices);

  if (!choices.length) {
    const btn = document.createElement("button");
    btn.textContent = "Schließen";
    btn.onclick = () => overlay.style.display = "none";
    box.appendChild(btn);
    return;
  }

  for (const choice of choices) {
    const btn = document.createElement("button");
    btn.textContent = choice.label;

    btn.onclick = async () => {
  await savePlayerChoice(event.id, choice.id);

  // ⭐ HIER: Forced Event als erledigt markieren
  if (event.__forcedPoiId) {
    await saveDiscovery(event.__forcedPoiId);
  }

  text.textContent = choice.result_text;
  box.innerHTML = "";

  const close = document.createElement("button");
  close.textContent = "Weiter";
  close.onclick = () => overlay.style.display = "none";
  box.appendChild(close);
};


    box.appendChild(btn);
  }
}

async function getForcedEvents(poiId) {
  const { data } = await sb
    .from("poi_events")
    .select("*")
    .eq("poi_id", poiId)
    .eq("event_type", "forced")
    .eq("auto_trigger", true);

  return data || [];
}
async function triggerForcedEvent(event, poiId) {
  if (forcedEventActive) return;
  forcedEventActive = true;

  // Forced Event merkt sich, zu welchem POI es gehört
  event.__forcedPoiId = poiId;

  await openInspectEvent(event);

  // Overlay beobachten
  const overlay = document.getElementById("event-overlay");
  const observer = new MutationObserver(() => {
    if (overlay.style.display === "none") {
      forcedEventActive = false;
      observer.disconnect();
    }
  });

  observer.observe(overlay, { attributes: true });
}




/* ================= POIs ================= */
const poiMarkers = new Map();

async function loadPOIs() {
  const { data: pois } = await sb
    .from("pois")
    .select("*")
    .eq("active", true);

  for (const poi of pois) {

    const forced = await getForcedEvents(poi.id);
    if (forced.length && !(await hasDiscovered(poi.id))) {
      const d = distance(userLat, userLng, poi.lat, poi.lng);
      if (d <= forced[0].trigger_radius) {
        await triggerForcedEvent(forced[0], poi.id);
        continue;
      }
    }

    if (poi.is_visible && !poiMarkers.has(poi.id)) {
      const marker = L.marker(
      [poi.lat, poi.lng],
      { icon: defaultPoiIcon }
).addTo(map);
      marker.on("click", async () => {
        if (distance(userLat, userLng, poi.lat, poi.lng) > 15) return;
        const event = await getInspectEvent(poi.id);
        if (event) await openInspectEvent(event);
      });
      poiMarkers.set(poi.id, marker);
    }

    const d = distance(userLat, userLng, poi.lat, poi.lng);
    if (d <= poi.radius && !(await hasDiscovered(poi.id))) {
      showAlert("Entdeckt: " + poi.name);
      await saveDiscovery(poi.id);
    }
  }
}

/* ================= START ================= */
initAuth().then(startGPS);
</script>

</body>
</html>
